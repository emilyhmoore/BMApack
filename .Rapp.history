library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x <- matrix(rnorm(30),ncol=3)
colnames(x) <- paste("X",1:3,sep="")
y <- rnorm(10)
fitBMA(x,y)
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  s#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- apply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob))#
          }#close function definition#
)
fitBMA(x,y)
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- apply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob))#
          }#close function definition#
)
fitBMA(x,y)
set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})
set
set<-unlist(set, recursive=F)
run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }
list1<-llply(1:length(set), run.regs)
list1<-unlist(list1, recursive=F)
fits<-llply(list1, function(x){summary(x)[['r.squared']]})
fits<-unlist(fits)
coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }
coefs<-llply(1:length(set), coef.fun)
gs<-rep(g, length(set)) ##make a vector of the g value
g<-3
gs<-rep(g, length(set)) ##make a vector of the g value
ns<-rep(length(y), length(set)) ##make a vector of the n value
pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }
pks <- llply(1:length(set), pks.fun) ##running llply over "set."
pks <- unlist(pks) ##unlisting pks
pks <- as.numeric(pks) ##assigning numeric class to pks
r2s<-fits##r2 values
values<-cbind(gs, ns, pks, r2s)##make matrix of these
bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }
bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)
sum.bmk<-sum(bmk.vec)
lculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }
odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }
odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk
odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk
odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk
xiny<-function(y,x){x %in% y}
applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }
theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }
themods<-laply(1:ncol(x), theodds)
coefnamer<-function(i){
coefvec<-unlist(coefs) ##turn list of coefs into a vector.
coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name
coef1<-coefvec[coefname]
return(coef1)
}
thecoefs<-llply(1:ncol(x), coefnamer)
thecoefs<-unlist(thecoefs)
thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)
rownames(thecoefs)<-colnames(x)
ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices
exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows
exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1
names(exp.val)<-colnames(x)
coefprob<-aaply(themods, 1, sum)
names(coefprob)<-colnames(x)
index <- apply(thecoefs,1,function(x){which(x>0)})
coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))
index
index <- apply(thecoefs,1,function(x){which(x>0)})
index
thecoefs
index
index <- laply(thecoefs,1,function(x){which(x>0)})
index <- alply(thecoefs,1,function(x){which(x>0)})
index
index <- lply(thecoefs,1,function(x){which(x>0)})
index <- alply(thecoefs,1,function(x){which(x>0)})
index
coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))
coefprb.largerthanzero
coefprob.largerthanzero
index <- alply(thecoefs,1,function(x){which(x>0)})
coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- alply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob))#
          }#close function definition#
)
fitBMA(x,y)
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- alply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob,coefprobs.largerthanzero=coefprob.largerthanzero))
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- alply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob,coefprobs.largerthanzero=coefprob.largerthanzero))#
          }#close function definition#
)
fitBMA(x,y)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x <- matrix(rnorm(30),ncol=3)
colnames(x) <- paste("X",1:3,sep="")
y <- rnorm(10)
fitBMA(x,y)
h <- fitBMA(x,y)
summary(h)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
help(fitBMA)
install(pkg=current.code, local=TRUE)
help(fitBMA)
help.search('summary,bma-method')
example(fitBMA)
example('summary,bma-method')
example('plot,bma-method') ##may take a sec
x <- matrix(rnorm(30),ncol=3)
colnames(x) <- paste("X",1:3,sep="")
y <- rnorm(10)
run.regs2 <- function(i){#
    list2 <- list(NULL)#
    list2 <- list(summary(lm(scale(y)~-1+scale(x[,set[[i]]])))$coefficients[,2])#
    return(list2)#
  }
library(plyr)
set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)},
set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})
se
set
set<-unlist(set, recursive=F)
run.regs2
list2<-llply(1:length(set), run.regs2)
list2
list2 <- unlist(list2, recursive=F)
list2
SE.fun <- function(i){#
    SEs <- list()#
    SEs <- setNames(list2[[i]], colnames(x)[set[[i]]])#
    return(SEs)#
  }
list2
x
set
SEs <-llply(1:length(set), SE.fun)
SEs
SEmatrix <- matrix(0, ncol=length(SEs), nrow=ncol(x))
Ses
SEs
SEmatrix
rownames(SEmatrix) <- paste("x", 1:ncol(x), sep="")
SEmatrix
matnames <- rownames(SEmatrix)
matnames
SEmatrix <- maply(1:length(SEs),function(x){SEs[[x]][matnames]})
SEmatrix
SEmatrix <- t(as.matrix(SEmatrix))
SEmatrix
SEmatrix[is.na(SEmatrix)] <- 0
PosteriorSE <- SEmatrix %*% odds.bmk
plot
x
y
fitBMA(x,y)
x <- fitBMA(x,y)
probs <- 1-x@coefprobs
probs
str(x)
coef.plot <- function(i){#
              plot(density(rnorm(n=nrow(x@x), mean=x@exp.vals[i], sd=x@exp.ses[i])), #
                   main=paste("Variable", i), xlab="", ylab="")#
              segments(0,0,0,probs[i], lwd=3)#
            }
plot(density(rnorm(n=nrow(x@x), mean=x@exp.vals[1], sd=x@exp.ses[1])), #
                   main=paste("Variable", 1), xlab="", ylab="")
probs
segments(0,0,0,probs[1], lwd=3)
l_ply(1:length(x@exp.vals), coef.plot)
x@exp.vals
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x <- matrix(rnorm(40),ncol=3)
x <- matrix(rnorm(40),ncol=4)
colnames(x) <- paste("X",1:4,sep="")
y <- rnorm(10)
fitBMA(x,y)
summar(fitBMA(x,y))
summary(fitBMA(x,y))
plot(x,y)
plot(fitBMA(x,y))
char.vec<-paste("var", 1:15)
char.vec
input <- char.vec[c(1,2)]
input
names<-(input) ##For now since the input is a character vector, it's just the input
names
parallel <- FALSE
set <- llply(1:length(input),function(X){combn(length(input),X,simplify=F)}, #
               .parallel=parallel)
set
set<-unlist(set, recursive=F)
set
names[set[[1]]]
names
names[set[[3]]]
named.set<-llply(1:length(set), function(i){names[set[[i]]]}, .parallel=parallel)
named.set
good.models<-list()
all.nothing
all.nothing<- naes
all.nothing<- names
all.nothing
all.nothing %in% named.set[[1]]
named.set
all.nothing %in% named.set[[2]]
all.nothing %in% named.set[[3]]
if(length(all.nothing)==0){good.models<-set} else{#
  ##are the variables in there?#
  all.nothingset<-llply(1:length(named.set), function(i){all.nothing %in% named.set[[i]]}, .parallel=parallel)
all.nothingset<-llply(1:length(named.set), function(i){all.nothing %in% named.set[[i]]}, .parallel=parallel)
all.nothingset
unique(all.nothingset[[1]])
unique(all.nothingset[[2]])
unique(all.nothingset[[3]])
theall.nothings<-llply(1:length(all.nothingset),function(i){length(unique(all.nothingset[[i]]))==1},#
                         .parallel=parallel)
theall.nothings
pick.me<-which(theall.nothings==TRUE)
pick.me
named.set
good.models<-named.set[pick.me]
good.models
good.models2<-list()
either.orset<-llply(1:length(good.models), function(i){either.or %in% good.models[[i]]},#
                      .parallel=parallel)
named
names
either.or<-names
either.orset<-llply(1:length(good.models), function(i){either.or %in% good.models[[i]]},#
                      .parallel=parallel)
either.orset
good.models
theeither.ors<-llply(1:length(either.orset),function(i){length(unique(either.orset[[i]]))==1},#
                       .parallel=parallel)
theeither.ors
either.or
pick.me2<-which(theeither.ors==FALSE)
pick.me2
good.models2<-good.models[pick.me2]
good.models2
good.models3<-list()
one.if.other <- names
one.if.other
good.models
one.if.otherset<-llply(1:length(good.models), function(i){one.if.other %in% good.models[[i]]},#
                         .parallel=parallel)
one.if.otherset
good.models
one.if.other
one.in.model<-llply(1:length(one.if.otherset), #
                      function(i){#
                        one.if.otherset[[i]][1]==TRUE & #
                          all(one.if.otherset[[i]][2:length(one.if.other)])==FALSE#
                      },#
                      .parallel=parallel#
                      )
one.in.model
pick.me3<-which(one.in.model==FALSE)
pick.me3
good.models3<-good.models2[pick.me3]
good.models3
char.vec
model.selector(char.vec, #
               either.or=NULL, #
               all.nothing=c("var 1", "var 2"),#
               one.if.other=c("var 3", "var 4", "var 5")#
               )
char.vec<-paste("var", 1:15)#
#
##either.or variables are those in which one is included or the other but never both#
##all.nothing variables are those in which a set should always be included or never included #
##one.if.other are variables such as squares and interactions that must include constituent terms#
#
model.selector<-function(input, either.or=NULL, all.nothing=NULL, one.if.other=NULL, parallel=FALSE){#
  if(length(all.nothing)==1){stop("If specifying All.nothing, it must have at least two variables")}#
  if(length(either.or)==1){stop("If specifying Either.or, it must have at least two variables")}#
  if(length(one.if.other)==1){stop("If specifying one.if.other, it must have at least two variables")}#
  names<-(input) ##For now since the input is a character vector, it's just the input#
  set <- llply(1:length(input),function(X){combn(length(input),X,simplify=F)}, #
               .parallel=parallel)#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
  ##setting variable names#
  named.set<-llply(1:length(set), function(i){names[set[[i]]]}, .parallel=parallel)#
  good.models<-list()#
#
  if(length(all.nothing)==0){good.models<-set} else{#
  ##are the variables in there?#
  all.nothingset<-llply(1:length(named.set), function(i){all.nothing %in% named.set[[i]]}, .parallel=parallel)#
#
  ##if the length of the unique is one, it means either all or none of the all.nothings are included#
  theall.nothings<-llply(1:length(all.nothingset),function(i){length(unique(all.nothingset[[i]]))==1},#
                         .parallel=parallel)#
#
  ##these are the models we want, so which ones are they??#
  pick.me<-which(theall.nothings==TRUE)#
  ##This is the reduced set of models#
  good.models<-named.set[pick.me]#
  }#
  good.models2<-list()#
  if(length(either.or)==0){good.models2<-good.models} else{#
  either.orset<-llply(1:length(good.models), function(i){either.or %in% good.models[[i]]},#
                      .parallel=parallel)#
#
  ##if the length of the unique is one, it means either all or none of the all.nothings are included#
  theeither.ors<-llply(1:length(either.orset),function(i){length(unique(either.orset[[i]]))==1},#
                       .parallel=parallel)#
  pick.me2<-which(theeither.ors==FALSE)#
#
  good.models2<-good.models[pick.me2]#
  }#
  good.models3<-list()#
  if(length(one.if.other)==0){good.models3<-good.models2} else{#
  one.if.otherset<-llply(1:length(good.models), function(i){one.if.other %in% good.models[[i]]},#
                         .parallel=parallel)#
  ##the all function returns TRUE if ALL of the values are true. This calls the model a TRUE #
  ##if the first variable in #
  ##the string IS INCLUDED and ANY of the other variables are not. #
  ##If the first variable is not included or the variable of interest AND ALL the others are included, it #
  ##will be a FALSE. I.e. if variable 3 should be included only when 4 is, and only 3 is there, it calls#
  ##that model a TRUE. #
  one.in.model<-llply(1:length(one.if.otherset), #
                      function(i){#
                        one.if.otherset[[i]][1]==TRUE & #
                          all(one.if.otherset[[i]][2:length(one.if.other)])==FALSE#
                      },#
                      .parallel=parallel#
                      )#
  pick.me3<-which(one.in.model==FALSE)#
#
  good.models3<-good.models2[pick.me3]#
#
  } ##close if else#
#
  return(good.models3)#
}
model.selector(char.vec, #
               either.or=NULL, #
               all.nothing=c("var 1", "var 2"),#
               one.if.other=c("var 3", "var 4", "var 5")#
               )
system.time(trial<-model.selector(char.vec, #
               either.or=NULL, #
               all.nothing=c("var 1", "var 2"),#
               one.if.other=c("var 3", "var 4", "var 5")#
               ))
