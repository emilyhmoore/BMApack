x <- matrix(rnorm(80),ncol=8)
x
colnames(x) <- paste("X",1:8,sep="")
y <- rnorm(10)
g <- 3
allNothing <- c("X1","X2")
eitherOr <- c("X3","X4")
always <- "X5"
parallel <- FALSE
varNames <- colnames(x)
if(length(allNothing)==1){stop("If specifying allNothing, #
                                             it must have at least two variables")}#
  		        if(length(eitherOr)==1){stop("If specifying eitherOr, #
                                           it must have at least two variables")}
conditionals<-c(allNothing,always,eitherOr)
conditionalsIndex <- which(varNames%in%conditionals)#
  		        unconditionals <- varNames[-conditionalsIndex]
alwaysCondition <- TRUE
allNothingCondition<-c(TRUE, FALSE)
conditionalsList<-list(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)
otherConditionals<-conditionals[-c(which(conditionals%in%always), #
                                                which(conditionals%in%allNothing))]
otherConditionalsList<-list()#
		          otherConditionalsList<-llply(1:length(otherConditionals),#
                                          function(i){otherConditionalsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)
library(plyr)
otherConditionalsList<-list()#
		          otherConditionalsList<-llply(1:length(otherConditionals),#
                                          function(i){otherConditionalsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)
names(otherConditionalsList)<-otherConditionals
conditionalsList<-c(conditionalsList, otherConditionalsList)
conditionalsModels <- expand.grid(conditionalsList)
conditionalsMatrix <-matrix(rep(FALSE),ncol=length(c(allNothing, always)), #
                                      nrow=nrow(conditionalsModels))
colnames(conditionalsMatrix)<-c(allNothing, always)
conditionalsMatrix[,always]<-conditionalsModels[,"alwaysCondition"]
conditionalsMatrix[,allNothing]<-conditionalsModels[,"allNothingCondition"]
conditionalsMatrix<-cbind(conditionalsMatrix,conditionalsModels[,otherConditionals])
unconditionalsList<-list()
if(length(unconditionals)!=0){#
                length(unconditionalsList)<-length(unconditionals)#
  		          unconditionalsList<-llply(1:length(unconditionals), #
  		                                    function(i){unconditionalsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unconditionalsList<-c(unconditionalsList, list(temp=1:nrow(conditionalsMatrix)))#
                names(unconditionalsList)<-c(unconditionals, "temp")#
  		        }
unconditionalsMatrix <- expand.grid(unconditionalsList)
bindTogether<-function(i){cbind(unconditionalsMatrix[unconditionalsMatrix$temp==i,], conditionalsMatrix[i,])}
modelMatrix<-do.call("rbind",llply(1:nrow(conditionalsMatrix), bindTogether))
modelMatrix$temp<-NULL
modelMatrix<-modelMatrix[colnames(x)]
modelMatrix
modelSelect<-function(varNames, #
                                    parallel,#
                                    allNothing, #
                                    eitherOr,#
                                    always#
                                    )#
              { #
		          ##Throw errors if the conditions specified are inappropriate.#
  		        if(length(allNothing)==1){stop("If specifying allNothing, #
                                             it must have at least two variables")}#
  		        if(length(eitherOr)==1){stop("If specifying eitherOr, #
                                           it must have at least two variables")}#
  		        ##The conditionals object contains variables that are conditioned.#
  		        conditionals<-c(allNothing,always,eitherOr)#
  		        ##conditionalsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        conditionalsIndex <- which(varNames%in%conditionals)#
  		        unconditionals <- varNames[-conditionalsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-c(TRUE, FALSE)#
		          ###
              ##We will need to be able to take lists of allnothings eventually.#
              ###
		          ##The conditionalsList is all configurations for the conditioned variables combined.#
		          conditionalsList<-list(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              ##This is all conditionals that are not always or allNothing types#
  		        otherConditionals<-conditionals[-c(which(conditionals%in%always), #
                                                which(conditionals%in%allNothing))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherConditionalsList<-list()#
		          otherConditionalsList<-llply(1:length(otherConditionals),#
                                          function(i){otherConditionalsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
		          names(otherConditionalsList)<-otherConditionals#
              conditionalsList<-c(conditionalsList, otherConditionalsList)#
#
              ##Expand grid on the conditioned variables.#
              conditionalsModels <- expand.grid(conditionalsList)#
#
              conditionalsMatrix <-matrix(rep(FALSE),ncol=length(c(allNothing, always)), #
                                      nrow=nrow(conditionalsModels))#
              colnames(conditionalsMatrix)<-c(allNothing, always)#
		          ##Put in the configurations for the alwaysCondition variables into conditionalsMatrix.#
		          conditionalsMatrix[,always]<-conditionalsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition.This should look the same #
              ##for each variable in a set of allNothings #
		          conditionalsMatrix[,allNothing]<-conditionalsModels[,"allNothingCondition"]#
              ##cbind that to the expandgrid results for any of the "otherConditionals" #
              ##which is just conditionals that are not always or allNothing types.#
              ##They vary as normal in expand grid and are stripped out later.#
              conditionalsMatrix<-cbind(conditionalsMatrix,conditionalsModels[,otherConditionals])#
              ################################################################################
              ###############This is where we need to strip out "bad" models##################
              ###############BEFORE the temp variable is created for use with#################
              ###############the unconditionals###############################################
              ################################################################################
  		        ##This is an empty list for the unconditioned variables that will be put into the expand.grid function.#
  		        unconditionalsList<-list()#
  		        ##The unconditionalsList will not be created if all variables are conditioned. #
  		        ##If there are unconditioned variables, however, the following code generates a #
  		        ##list that says TRUE and FALSE for each unconditioned variable.#
  		        if(length(unconditionals)!=0){#
                length(unconditionalsList)<-length(unconditionals)#
  		          unconditionalsList<-llply(1:length(unconditionals), #
  		                                    function(i){unconditionalsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unconditionalsList<-c(unconditionalsList, list(temp=1:nrow(conditionalsMatrix)))#
                names(unconditionalsList)<-c(unconditionals, "temp")#
  		        }#
  		        ##Expand grid on the unconditioned variables.#
  		        unconditionalsMatrix <- expand.grid(unconditionalsList)#
              ##This function matches the models with a particular temp value to a row #
              ##in the conditionalsMatrix #
              ##Thus, for each model where temp==1 in unconditionals, we match it to the first row#
              ##of the conditionals. Same with 2 and so on all the way through the number of rows#
              ##in the unconditionals matrix (number of those type of models.#
              bindTogether<-function(i){cbind(unconditionalsMatrix[unconditionalsMatrix$temp==i,], conditionalsMatrix[i,])}#
              ##Here, I'm llplying over all of the rows of the conditioned variable combination matrix#
              ##This is because temp in the unconditional matrix takes on a new value for each model #
              ##in the conditioned matrix.So this matches temp==1 in unconditioned to row 1 #
              ##of the conditioned matrix #
              ##lply returns a list and laply doesn't work in this context, so I use do.call with rbind#
              ##to get a matrix here.#
              modelMatrix<-do.call("rbind",llply(1:nrow(conditionalsMatrix), bindTogether))#
              ##Finally, we remove temp. This makes it so modelMatrix is exactly the same but without#
              ##the temp variable.#
              modelMatrix$temp<-NULL#
              ##This ensures that the variables go back into the order they originally were in for the input#
              ##matrix of fitbma. This is essential because they can easily get out of order in the#
              ##conditioning process.#
              modelMatrix<-modelMatrix[colnames(x)]#
              return(modelMatrix)#
            }
modelMatrix
modelMatrix <- as.matrix(modelMatrix)
run.regs<-function(i){#
              thisLM <- lm(y~x[,i])#
              thisCoef <- coef(thisLM);  names(thisCoef) <- c("(Intercept)", colnames(x)[i])#
              thisSE <-  summary(thisLM)$coefficients[,2]; names(thisSE) <- c("(Intercept)", colnames(x)[i])#
              thisR2 <- summary(thisLM)$r.squared#
              return(list(coef=thisCoef, se=thisSE, R2=thisR2))#
            }
lmList<-alply(modelMatrix,1,run.regs, .parallel=parallel)
head(lmList)
thisLM <- lm(y~x[,modelMatrix[[1,]]])
thisLM <- lm(y~x[,modelMatrix[1,]]])
thisLM <- lm(y~x[,modelMatrix[1,]])
thisLM
?scale
thisLM <- lm(y~x[,modelMatrix[1,]]-1)
thisLM
thisLM <- lm(scale(y)~scale(x[,modelMatrix[1,]])-1)
thisLM
thisCoef <- coef(thisLM)
thisCoef
colnames(x)[modelMatrix[1,]]
modelMatrix[1,]
colnames(x)
names(thisCoef) <- colnames(x)[modelMatrix[1,]]
thisCoef
summary(thisLM)
summary(thisLM)$coefficients[,2]
thisSE <-  summary(thisLM)$coefficients[,2];
names(thisSE) <-colnames(x)[i]
names(thisSE) <-colnames(x)[modelMatrix[1,]]
thisSE
thisR2 <- summary(thisLM)$r.squared
run.regs<-function(i){#
              thisLM <- lm(scale(y)~scale(x[,i])-1)#
              thisCoef <- coef(thisLM);  names(thisCoef) <- colnames(x)[i]#
              thisSE <-  summary(thisLM)$coefficients[,2]; names(thisSE) <-colnames(x)[i]#
              thisR2 <- summary(thisLM)$r.squared#
              return(list(coef=thisCoef, se=thisSE, R2=thisR2))#
            }
lmList<-alply(modelMatrix,1,run.regs, .parallel=parallel)
lmList
head(lmList)
bayesFactor<-function(index){#
              bf <- (1+g)^((n-numberVars[index]-1)/2)*((1+g*(1-r2s[index]))^(-(n-1)/2))#
              names(bf)<-c("bf")#
              return(bf)#
            }
r2s<-laply(lmList, function(x){return(x[["R2"]])}, .parallel=parallel)
head(r2s)
coefs<-llply(lmList, function(x){return(x[["coef"]])}, .parallel=parallel)
standardErrors<-llply(lmList, function(x){return(x[["se"]])}, .parallel=parallel)
numberVars <- rowSums(modelMatrix)
numberVars
n <- length(y)
m <- nrow(modelMatrix) # number of total models
p <- ncol(modelMatrix)+1
bfVec<-aaply(1:m,.margins=1,.fun=bayesFactor, .parallel=parallel)
head(r2s)
postProb <- matrix(bfVec/sum(bfVec), ncol=1)
postProb
modelMatrix
dim(modelMatrix)
dim(postProb)
postProbcoefs <- t(modelMatrix)%*%postProb
coefMatrix <- sdMatrix <- cbind(rep(NA, m), modelMatrix)
coefMatrix
dim(coefMatrix)
coefMatrix <- sdMatrix <- modelMatrix
dim(coefMatrix)
dim(sdMatrix)
colnames(coefMatrix) <- colnames(sdMatrix) <- colnames(modelMatrix)
head(coefMatrix)
sdMatrix[modelMatrix==FALSE] <- coefMatrix[modelMatrix==FALSE] <- 0
head(coefMatrix)
m
coefs
for(i in 1:m){#
              coefMatrix[i,names(coefs[[i]])] <- coefs[[i]]#
            }
coefMatrix
for(i in 1:m){#
              sdMatrix[i,names(standardErrors[[i]])] <- standardErrors[[i]]#
            }
cbind(TRUE, modelMatrix)
head(modelMatrix)
expB <- t(coefMatrix)%*%postProb
exp
expB
p
expBcond <- rep(NA, p-1)#
            for(i in 1:(p-1)){#
              these <- (modelMatrix[,i]==TRUE)#
              expBcond[i] <- (coefMatrix[these,i])%*% (postProb[these,])#
            }
expBcond
these
modelMatrix
these
coefMatrix
coefMatrix[these,1]
postProb
postProb[these,]
these
expBcond
condSE <- rep(NA, p-1)#
            for(i in 1:(p-1)){#
              these <- (modelMatrix[,i]==TRUE)#
              condSE[i] <- (sdMatrix[these,i])^2%*% (postProb[these,])#
            }#
            condSE <- sqrt(condSE)
condSE
sdMatrix
largerZero <- rep(NA, p-1)#
            for(i in 1:(p-1)){#
              these <- (modelMatrix[,i]==TRUE)#
              largerZero[i] <- pnorm(0, coefMatrix[these,i], sdMatrix[these,i], lower.tail=FALSE) %*%(postProb[these,])#
             }
largerZero
pnorm(0,0,1)
pnorm(-.2,0,1)
postProb
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
setwd("/Users/jaeheejung/Desktop/Spring 2014/Applied Statistical Programming/BMApack")
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
fitBMA(x,y,g,parallel,allNothing,eitherOr,always)
a <- fitBMA(x,y,g,parallel,allNothing,eitherOr,always)
str(a)
summary(a)
plot(a)
load("/Users/jaeheejung/Desktop/Spring 2014/Applied Statistical Programming/BMApack/BMApack/data/ABDagg.rda")
head(ABDagg)
library(devtools)
library(roxygen2)
setwd("/Users/jaeheejung/Desktop/Spring 2014/Applied Statistical Programming/BMApack")
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x <- matrix(rnorm(80),ncol=8)
colnames(x) <- paste("X",1:8,sep="")
y <- rnorm(10)
fitBMA(x,y,g=3,parallel=FALSE,allNothing=c("X1","X2"),eitherOr=c("X3","X4"),always="X5")
a <- fitBMA(x,y,g=3,parallel=FALSE,allNothing=c("X1","X2"),eitherOr=c("X3","X4"),always="X5")
str(a)
help(fitBMA)
?fitBMA
plot(a)
summary(a)
help(fitBMA)
install(pkg=current.code, local=TRUE)
check(current.code)
help(fitBMA)
help.search('summary,bma-method')
example(fitBMA)
a
help(fitBMA)
help(summary)
help(fitBMA)
a <- fitBMA(x,y,g=3,parallel=FALSE,allNothing=c("X1","X2"),eitherOr=c("X3","X4"),always="X5")
a
help(fitBMA)
