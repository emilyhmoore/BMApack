aaply(restrictedsMatrix[eitherOr[[1]]], 1, eitherOrTest)
unlist(alply(restrictedsMatrix[eitherOr[[1]]], 1, eitherOrTest))
eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- list(eitherOrTestResults,eitherOrStripIndex)#
              	}
eitherOrTestResults
eitherOrTestResults[1]
eitherOrTestResults[1][1]
eitherOrTestResults[1][[1]]
eitherOrTestResults
restrictedsMatrix
eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}
eitherOrTestResults
matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)
eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)
eitherOrTestResults
head(restrictedsMatrix)
?all
aaply(eitherOrTestResults,1,function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })
eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })
eitherOrTestResultsCombined
head(restrictedsMatrix)
restrictedsMatrix<-restrictedsMatrix[eitherOrTestResults,]
restrictedsMatrix
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))#
  		        ##restrictedsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))#
              ##We will need to be able to take lists of allnothings eventually.#
              ###
		          ##The restrictedsList is all configurations for the conditioned variables combined.#
		          restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              allNothingConditionNames <- names(restrictedsList)[-1]#
              ##This is all restricteds that are not always or allNothing types#
  		        otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }#
                                           names(otherrestrictedsList)<-otherrestricteds#
              restrictedsList<-c(restrictedsList, otherrestrictedsList)#
#
              ##Expand grid on the conditioned variables.#
              restrictedsModels <- expand.grid(restrictedsList)#
#
              restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))#
              colnames(restrictedsMatrix)<-c(unlist(allNothing), always)#
		          ##Put in the configurations for the alwaysCondition variables into restrictedsMatrix.#
		          restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition.This should look the same #
              ##for each variable in a set of allNothings #
	for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}#
              ##cbind that to the expandgrid results for any of the "otherrestricteds" #
              ##which is just restricteds that are not always or allNothing types.#
              ##They vary as normal in expand grid and are stripped out later.#
              restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])#
              ################################################################################
              ###############This is where we need to strip out "bad" models##################
              ###############BEFORE the temp variable is created for use with#################
              ###############the unrestricteds################################################
              ################################################################################
              ##This strips out models that fail the eitherOr test. #
              ##Basically, it makes sure there is only one TRUE or all FALSES#
              ##I have the as.logical line in there because, for some reason,#
              ##it doesn't think the restrictedsMatrix is a logical.#
  		        eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}##good models are true#
              ##Cannot apply over the whole row or it will apply to always and allNothing too#
              ##so this indexes the matrix according only to those models in eitherOr#
              ##The unlist part is to get it as a vector that can be used for indexing the whole matrix.#
              eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}#
              eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)#
              eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })
eitherOrTestResultsCombined
length(eitherOrTestResultsCombined)
restrictedsMatrix
restrictedsMatrix[eitherOrTestResults,]
eitherOrTestResults
restrictedsMatrix[eitherOrTestResultsCombined,]
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))#
  		        ##restrictedsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))#
              ##We will need to be able to take lists of allnothings eventually.#
              ###
		          ##The restrictedsList is all configurations for the conditioned variables combined.#
		          restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              allNothingConditionNames <- names(restrictedsList)[-1]#
              ##This is all restricteds that are not always or allNothing types#
  		        otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }#
                                           names(otherrestrictedsList)<-otherrestricteds#
              restrictedsList<-c(restrictedsList, otherrestrictedsList)#
#
              ##Expand grid on the conditioned variables.#
              restrictedsModels <- expand.grid(restrictedsList)#
#
              restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))#
              colnames(restrictedsMatrix)<-c(unlist(allNothing), always)#
		          ##Put in the configurations for the alwaysCondition variables into restrictedsMatrix.#
		          restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition.This should look the same #
              ##for each variable in a set of allNothings #
	for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}#
              ##cbind that to the expandgrid results for any of the "otherrestricteds" #
              ##which is just restricteds that are not always or allNothing types.#
              ##They vary as normal in expand grid and are stripped out later.#
              restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])#
              ################################################################################
              ###############This is where we need to strip out "bad" models##################
              ###############BEFORE the temp variable is created for use with#################
              ###############the unrestricteds################################################
              ################################################################################
              ##This strips out models that fail the eitherOr test. #
              ##Basically, it makes sure there is only one TRUE or all FALSES#
              ##I have the as.logical line in there because, for some reason,#
              ##it doesn't think the restrictedsMatrix is a logical.#
  		        eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}##good models are true#
              ##Cannot apply over the whole row or it will apply to always and allNothing too#
              ##so this indexes the matrix according only to those models in eitherOr#
              ##The unlist part is to get it as a vector that can be used for indexing the whole matrix.#
              eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}#
              eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)#
              eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })#
              ##This indexes the matrix (and resaves it) by the test results .#
              ##So if the test came back TRUE, the model is kept. If the test is false,#
              ##it removes that row.#
              restrictedsMatrix<-restrictedsMatrix[eitherOrTestResultsCombined,]
unrestrictedsList<-list()
if(length(unrestricteds)!=0){#
                length(unrestrictedsList)<-length(unrestricteds)#
  		          unrestrictedsList<-llply(1:length(unrestricteds), #
  		                                    function(i){unrestrictedsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unrestrictedsList<-c(unrestrictedsList, list(temp=1:nrow(restrictedsMatrix)))#
                names(unrestrictedsList)<-c(unrestricteds, "temp")#
  		        }
unrestrictedsList
unrestrictedsMatrix <- expand.grid(unrestrictedsList)
unrestrictedsMatrix
bindTogether<-function(i){cbind(unrestrictedsMatrix[unrestrictedsMatrix$temp==i,], restrictedsMatrix[i,])}
modelMatrix<-do.call("rbind",llply(1:nrow(restrictedsMatrix), bindTogether))
modelMatrix
modelMatrix$temp<-NULL
modelMatrix<-modelMatrix[colnames(x)]
modelMatrix
a
x <- a
varNames <- colnames(x)
allNothing
always
eitherOr
c(unlist(allNothing),always,unlist(eitherOr))
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))
which(varNames%in%restricteds)
restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]
alwaysCondition <- TRUE
replicate(length(allNothing),list(c(TRUE, FALSE)))
c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)
restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)
names(restrictedsList)[-1]
allNothingConditionNames <- names(restrictedsList)[-1]
allNothingConditionNames
allNothingCondition
restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]
otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]
otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }
otherrestricteds
names(otherrestrictedsList)<-otherrestricteds
c(restrictedsList, otherrestrictedsList)
restrictedsList<-c(restrictedsList, otherrestrictedsList)
restrictedsModels <- expand.grid(restrictedsList)
matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))
restrictedsModels
matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))
restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))
colnames(restrictedsMatrix)<-c(unlist(allNothing), always)
restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]
head(restrictedsMatrix)
for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}
head(restrictedsMatrix)
allNothingCondition
head(restrictedsModels)
allNothing
for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}
head(restrictedsModels)
head(restrictedsMatrix)
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))#
  		        ##restrictedsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))#
		          ##The restrictedsList is all configurations for the conditioned variables combined.#
		          restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              ##Save the list names of the allNothingConditions in order to use them as indices later.#
              allNothingConditionNames <- names(restrictedsList)[-1]#
              ##This is all restricteds that are not always or allNothing types#
  		        otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }#
                                           names(otherrestrictedsList)<-otherrestricteds#
              restrictedsList<-c(restrictedsList, otherrestrictedsList)#
#
              ##Expand grid on the conditioned variables.#
              restrictedsModels <- expand.grid(restrictedsList)#
              restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))#
              colnames(restrictedsMatrix)<-c(unlist(allNothing), always)#
		          ##Put in the configurations for the alwaysCondition variables into restrictedsMatrix.#
		          restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition. Since the allNothingCondition is a list, each list should be considered separately.#
	for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}
head(restrictedsModels)
otherrestricteds
head(restrictedsMatrix)
restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])
eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}
eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}
eitherOrTestResults
eitherOrCondition
eitherOr
eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)
eitherOrTestResults
eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })
eitherOrTestResultsCombined
restrictedsMatrix<-restrictedsMatrix[eitherOrTestResultsCombined,]
restrictedsMatrix
eitherOr
allNothing
restrictedsMatrix[,6:9]
library(devtools)
library(roxygen2)
setwd("/Users/jaeheejung/Desktop/Spring 2014/Applied Statistical Programming/BMApack")
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x
y
fitBMA(x,y,g,parallel,allNothing,eitherOr,always)
summary(fitBMA(x,y,g,parallel,allNothing,eitherOr,always))
plot(fitBMA(x,y,g,parallel,allNothing,eitherOr,always))
allNothing
always
eitherOr
fitBMA(x,y,g,parallel,allNothing,c("X5","X10"),eitherOr)
fitBMA(x,y,g,parallel,allNothing,eitherOr,c("X5","X10"))
fitBMA(x,y,g,parallel,allNothing,eitherOr,always)
always <- c("X5","X10")
always
allNothing
eitherOr
x
y
a
varNames <- colnames(x)
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))
restricteds
restrictedsIndex <- which(varNames%in%restricteds)
unrestricteds <- varNames[-restrictedsIndex]
unrestricteds
alwaysCondition <- TRUE
allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))
allNothingCondition
restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)
restrictedsList
allNothingConditionNames <- names(restrictedsList)[-1]
allNothingConditionNames
otherrestricteds<-restricteds[-c(which(restricteds%in%always),
which(restricteds%in%unlist(allNothing)))]
otherrestricteds
otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }
names(otherrestrictedsList)<-otherrestricteds
restrictedsList<-c(restrictedsList, otherrestrictedsList)
restrictedsList
restrictedsModels <- expand.grid(restrictedsList)
restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))
restrictedsMatrix
colnames(restrictedsMatrix)<-c(unlist(allNothing), always)
restrictedsMatrix
restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]
restrictedsMatrix
for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}
restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])
eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}##good models are true
eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}
eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)
eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })
restrictedsMatrix<-restrictedsMatrix[eitherOrTestResultsCombined,]
if(length(unrestricteds)!=0){#
                length(unrestrictedsList)<-length(unrestricteds)#
  		          unrestrictedsList<-llply(1:length(unrestricteds), #
  		                                    function(i){unrestrictedsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unrestrictedsList<-c(unrestrictedsList, list(temp=1:nrow(restrictedsMatrix)))#
                names(unrestrictedsList)<-c(unrestricteds, "temp")#
  		        }
unrestrictedsList
unrestricteds
length(unrestricteds)!=0
unrestrictedsMatrix <- expand.grid(unrestrictedsList)
unrestrictedsMatrix
length(unrestricteds)
length(unrestrictedsList)
unrestrictedsList
unrestrictedsList<-list()
unrestrictedsList
if(length(unrestricteds)!=0){#
                length(unrestrictedsList)<-length(unrestricteds)#
  		          unrestrictedsList<-llply(1:length(unrestricteds), #
  		                                    function(i){unrestrictedsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unrestrictedsList<-c(unrestrictedsList, list(temp=1:nrow(restrictedsMatrix)))#
                names(unrestrictedsList)<-c(unrestricteds, "temp")#
  		        }
unrestrictedsList
unrestrictedsMatrix <- expand.grid(unrestrictedsList)
unrestrictedsMatrix
bindTogether<-function(i){cbind(unrestrictedsMatrix[unrestrictedsMatrix$temp==i,], restrictedsMatrix[i,])}
modelMatrix<-do.call("rbind",llply(1:nrow(restrictedsMatrix), bindTogether))
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))#
  		        ##restrictedsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))#
		          ##The restrictedsList is all configurations for the conditioned variables combined.#
		          restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              ##Save the list names of the allNothingConditions in order to use them as indices later.#
              allNothingConditionNames <- names(restrictedsList)[-1]#
              ##This is all restricteds that are not always or allNothing types#
  		        otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }#
                                           names(otherrestrictedsList)<-otherrestricteds#
              restrictedsList<-c(restrictedsList, otherrestrictedsList)#
#
              ##Expand grid on the conditioned variables.#
              restrictedsModels <- expand.grid(restrictedsList)#
              restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))#
              colnames(restrictedsMatrix)<-c(unlist(allNothing), always)#
		          ##Put in the configurations for the alwaysCondition variables into restrictedsMatrix.#
		          restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition. Since the allNothingCondition is a list, each list should be considered separately.#
	for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}#
              ##cbind that to the expandgrid results for any of the "otherrestricteds" #
              ##which is just restricteds that are not always or allNothing types.#
              ##They vary as normal in expand grid and are stripped out later.#
              restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])#
              ################################################################################
              ###############This is where we need to strip out "bad" models##################
              ###############BEFORE the temp variable is created for use with#################
              ###############the unrestricteds################################################
              ################################################################################
              ##This strips out models that fail the eitherOr test. #
              ##Basically, it makes sure there is only one TRUE or all FALSES#
              ##The as.logical line in there because, for some reason,#
              ##it doesn't think the restrictedsMatrix is a logical.#
  		        eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}##good models are true#
              ##Cannot apply over the whole row or it will apply to always and allNothing too#
              ##so this indexes the matrix according only to those models in eitherOr#
              ##The unlist part is to get it as a vector that can be used for indexing the whole matrix.#
              eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}#
              ##Since eitherOrTestResults is a vector, transform it into a matrix with rows indicating each set of the eitherOr condition and rows indicating model numbers. The transformation into a matrix is for convenience in the next part. #
              eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)#
              ##Given the matrix of eitherOrTestResults, create a vector whose element is TRUE if all eitherOr conditions are TRUE. Otherwise, it is FALSE. This is done because if the user specifies more than one eitherOr condition, models for which the conditions hold for all eitherOr conditions should be calculated.#
              eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })#
              ##This indexes the matrix (and resaves it) by the test results .#
              ##So if the test came back TRUE, the model is kept. If the test is false,#
              ##it removes that row.#
              restrictedsMatrix<-restrictedsMatrix[eitherOrTestResultsCombined,]#
              ##I have a few ideas on how the other tests can be incorporated. I think we should#
              ##index bad models out all at once. So perhaps we can run all the test results into a matrix#
              ##with a column for each test and a row for each model in modelMatrix #
              ##(There would be one column for each eitherOr specified #
              ##and one for each set of interactions or squared dependency types.)#
              ##Then, we have a vector used for indexing. This vector has a true if all the tests are #
              ##passed (so all values in each test matrix row are true). If there is even one false,#
              ##the vector of results should return false. So, we end up with a vector with the a value#
              ##correspnding to each row of the matrix, then we can use it as I did above.#
              ##I'm open to anything, so whatever you want is fine. Delete this comment when we've #
              ##figured this out.#
              ######################End Tests#################################################
  		        ##This is an empty list for the unconditioned variables that will be put into the expand.grid function.#
  		        unrestrictedsList<-list()#
  		        ##The unrestrictedsList will not be created if all variables are conditioned. #
  		        ##If there are unconditioned variables, however, the following code generates a #
  		        ##list that says TRUE and FALSE for each unconditioned variable.#
  		        if(length(unrestricteds)!=0){#
                length(unrestrictedsList)<-length(unrestricteds)#
  		          unrestrictedsList<-llply(1:length(unrestricteds), #
  		                                    function(i){unrestrictedsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unrestrictedsList<-c(unrestrictedsList, list(temp=1:nrow(restrictedsMatrix)))#
                names(unrestrictedsList)<-c(unrestricteds, "temp")#
  		        }#
  		        ##Expand grid on the unconditioned variables.#
  		        if(length(unrestrictedsList)!=0){#
  		        	unrestrictedsMatrix <- expand.grid(unrestrictedsList)#
  		        }
unrestrictedsList
bindTogether<-function(i){cbind(unrestrictedsMatrix[unrestrictedsMatrix$temp==i,], restrictedsMatrix[i,])}
modelMatrix<-do.call("rbind",llply(1:nrow(restrictedsMatrix), bindTogether))
restricteds<-c(unlist(allNothing),always,unlist(eitherOr))#
  		        ##restrictedsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))#
		          ##The restrictedsList is all configurations for the conditioned variables combined.#
		          restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              ##Save the list names of the allNothingConditions in order to use them as indices later.#
              allNothingConditionNames <- names(restrictedsList)[-1]#
              ##This is all restricteds that are not always or allNothing types#
  		        otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }#
                                           names(otherrestrictedsList)<-otherrestricteds#
              restrictedsList<-c(restrictedsList, otherrestrictedsList)#
#
              ##Expand grid on the conditioned variables.#
              restrictedsModels <- expand.grid(restrictedsList)#
              restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))#
              colnames(restrictedsMatrix)<-c(unlist(allNothing), always)#
		          ##Put in the configurations for the alwaysCondition variables into restrictedsMatrix.#
		          restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition. Since the allNothingCondition is a list, each list should be considered separately.#
	for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}#
              ##cbind that to the expandgrid results for any of the "otherrestricteds" #
              ##which is just restricteds that are not always or allNothing types.#
              ##They vary as normal in expand grid and are stripped out later.#
              restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])#
              ################################################################################
              ###############This is where we need to strip out "bad" models##################
              ###############BEFORE the temp variable is created for use with#################
              ###############the unrestricteds################################################
              ################################################################################
              ##This strips out models that fail the eitherOr test. #
              ##Basically, it makes sure there is only one TRUE or all FALSES#
              ##The as.logical line in there because, for some reason,#
              ##it doesn't think the restrictedsMatrix is a logical.#
  		        eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}##good models are true#
              ##Cannot apply over the whole row or it will apply to always and allNothing too#
              ##so this indexes the matrix according only to those models in eitherOr#
              ##The unlist part is to get it as a vector that can be used for indexing the whole matrix.#
              eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}#
              ##Since eitherOrTestResults is a vector, transform it into a matrix with rows indicating each set of the eitherOr condition and rows indicating model numbers. The transformation into a matrix is for convenience in the next part. #
              eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)#
              ##Given the matrix of eitherOrTestResults, create a vector whose element is TRUE if all eitherOr conditions are TRUE. Otherwise, it is FALSE. This is done because if the user specifies more than one eitherOr condition, models for which the conditions hold for all eitherOr conditions should be calculated.#
              eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })#
              ##This indexes the matrix (and resaves it) by the test results .#
              ##So if the test came back TRUE, the model is kept. If the test is false,#
              ##it removes that row.#
              restrictedsMatrix<-restrictedsMatrix[eitherOrTestResultsCombined,]
restrictedsMatrix
bindTogether<-function(i){cbind(unrestrictedsMatrix[unrestrictedsMatrix$temp==i,], restrictedsMatrix[i,])}
unrestrictedsList<-list()
if(length(unrestricteds)!=0){#
                length(unrestrictedsList)<-length(unrestricteds)#
  		          unrestrictedsList<-llply(1:length(unrestricteds), #
  		                                    function(i){unrestrictedsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unrestrictedsList<-c(unrestrictedsList, list(temp=1:nrow(restrictedsMatrix)))#
                names(unrestrictedsList)<-c(unrestricteds, "temp")#
                   ##Expand grid on the unconditioned variables.#
                unrestrictedsMatrix <- expand.grid(unrestrictedsList)#
                  ##Here, I'm llplying over all of the rows of the conditioned variable combination matrix#
              ##This is because temp in the unrestricted matrix takes on a new value for each model #
              ##in the conditioned matrix.So this matches temp==1 in unconditioned to row 1 #
              ##of the conditioned matrix #
              ##lply returns a list and laply doesn't work in this context, so I use do.call with rbind#
              ##to get a matrix here.#
              modelMatrix<-do.call("rbind",llply(1:nrow(restrictedsMatrix), bindTogether))#
  		        }
modelMatrix
length(unrestricteds)!=0
modelMatrix <- restrictedsMatrix
modelMatrix
modelSelect<-function(varNames=colnames(x), #
                                    parallel,#
                                    allNothing, #
                                    eitherOr,#
                                    always#
                                    )#
              { #
  		        ##The restricteds object contains variables that are conditioned.#
  		        restricteds<-c(unlist(allNothing),always,unlist(eitherOr))#
  		        ##restrictedsIndex returns the index of the conditioned variables. #
              ##This is necessary because we want to separate the conditioned ones #
              ##from the unconditioned variables.#
  		        restrictedsIndex <- which(varNames%in%restricteds)#
  		        unrestricteds <- varNames[-restrictedsIndex]#
#
		          ##The always condition is always included.#
		          alwaysCondition <- TRUE#
		          ##The allNothing condition is either included or not included.#
		          allNothingCondition<-          replicate(length(allNothing),list(c(TRUE, FALSE)))#
		          ##The restrictedsList is all configurations for the conditioned variables combined.#
		          restrictedsList<-c(alwaysCondition=alwaysCondition, #
                                    allNothingCondition=allNothingCondition)#
              ##Save the list names of the allNothingConditions in order to use them as indices later.#
              allNothingConditionNames <- names(restrictedsList)[-1]#
              ##This is all restricteds that are not always or allNothing types#
  		        otherrestricteds<-restricteds[-c(which(restricteds%in%always), #
                                                which(restricteds%in%unlist(allNothing)))]#
              ##Make a list for the variables that are just going to be true false before they are #
              ##stripped away#
              otherrestrictedsList<-list()#
               if(length(otherrestricteds)!=0){#
		          otherrestrictedsList<-llply(1:length(otherrestricteds),#
                                          function(i){otherrestrictedsList[[i]]<-c(TRUE, FALSE)},#
                                          .parallel=parallel)#
                                          }#
                                           names(otherrestrictedsList)<-otherrestricteds#
              restrictedsList<-c(restrictedsList, otherrestrictedsList)#
#
              ##Expand grid on the conditioned variables.#
              restrictedsModels <- expand.grid(restrictedsList)#
              restrictedsMatrix <-matrix(rep(FALSE),ncol=length(c(unlist(allNothing), always)), #
                                      nrow=nrow(restrictedsModels))#
              colnames(restrictedsMatrix)<-c(unlist(allNothing), always)#
		          ##Put in the configurations for the alwaysCondition variables into restrictedsMatrix.#
		          restrictedsMatrix[,always]<-restrictedsModels[,"alwaysCondition"]#
#
		          ##Do the same for the allNothingCondition. Since the allNothingCondition is a list, each list should be considered separately.#
	for(i in 1:length(allNothing)){#
		restrictedsMatrix[,allNothing[[i]]]<-restrictedsModels[,allNothingConditionNames[i]]#
		}#
              ##cbind that to the expandgrid results for any of the "otherrestricteds" #
              ##which is just restricteds that are not always or allNothing types.#
              ##They vary as normal in expand grid and are stripped out later.#
              restrictedsMatrix<-cbind(restrictedsMatrix,restrictedsModels[,otherrestricteds])#
              ################################################################################
              ###############This is where we need to strip out "bad" models##################
              ###############BEFORE the temp variable is created for use with#################
              ###############the unrestricteds################################################
              ################################################################################
              ##This strips out models that fail the eitherOr test. #
              ##Basically, it makes sure there is only one TRUE or all FALSES#
              ##The as.logical line in there because, for some reason,#
              ##it doesn't think the restrictedsMatrix is a logical.#
  		        eitherOrTest<-function(x){length(which(x==TRUE))==1 | any(as.logical(x))==FALSE}##good models are true#
              ##Cannot apply over the whole row or it will apply to always and allNothing too#
              ##so this indexes the matrix according only to those models in eitherOr#
              ##The unlist part is to get it as a vector that can be used for indexing the whole matrix.#
              eitherOrTestResults <- NULL#
              for(i in 1:length(eitherOr)){#
              	eitherOrStripIndex <- unlist(alply(restrictedsMatrix[eitherOr[[i]]], 1, eitherOrTest))#
              	eitherOrTestResults <- c(eitherOrTestResults,eitherOrStripIndex)#
              	}#
              ##Since eitherOrTestResults is a vector, transform it into a matrix with rows indicating each set of the eitherOr condition and rows indicating model numbers. The transformation into a matrix is for convenience in the next part. #
              eitherOrTestResults <- matrix(eitherOrTestResults,ncol=length(eitherOr),byrow=FALSE)#
              ##Given the matrix of eitherOrTestResults, create a vector whose element is TRUE if all eitherOr conditions are TRUE. Otherwise, it is FALSE. This is done because if the user specifies more than one eitherOr condition, models for which the conditions hold for all eitherOr conditions should be calculated.#
              eitherOrTestResultsCombined <- aaply(eitherOrTestResults,1,#
              function(x){#
              	ifelse(all(x),TRUE,FALSE)#
              })#
              ##This indexes the matrix (and resaves it) by the test results .#
              ##So if the test came back TRUE, the model is kept. If the test is false,#
              ##it removes that row.#
              restrictedsMatrix<-restrictedsMatrix[eitherOrTestResultsCombined,]#
              ##I have a few ideas on how the other tests can be incorporated. I think we should#
              ##index bad models out all at once. So perhaps we can run all the test results into a matrix#
              ##with a column for each test and a row for each model in modelMatrix #
              ##(There would be one column for each eitherOr specified #
              ##and one for each set of interactions or squared dependency types.)#
              ##Then, we have a vector used for indexing. This vector has a true if all the tests are #
              ##passed (so all values in each test matrix row are true). If there is even one false,#
              ##the vector of results should return false. So, we end up with a vector with the a value#
              ##correspnding to each row of the matrix, then we can use it as I did above.#
              ##I'm open to anything, so whatever you want is fine. Delete this comment when we've #
              ##figured this out.#
              ######################End Tests#################################################
          ##This function matches the models with a particular temp value to a row #
              ##in the restrictedsMatrix #
              ##Thus, for each model where temp==1 in unrestricteds, we match it to the first row#
              ##of the restricteds. Same with 2 and so on all the way through the number of rows#
              ##in the unrestricteds matrix (number of those type of models.#
              bindTogether<-function(i){cbind(unrestrictedsMatrix[unrestrictedsMatrix$temp==i,], restrictedsMatrix[i,])}#
  		        ##This is an empty list for the unconditioned variables that will be put into the expand.grid function.#
  		        unrestrictedsList<-list()#
  		        ##The unrestrictedsList will not be created if all variables are conditioned. #
  		        ##If there are unconditioned variables, however, the following code generates a #
  		        ##list that says TRUE and FALSE for each unconditioned variable.#
  		        if(length(unrestricteds)!=0){#
                length(unrestrictedsList)<-length(unrestricteds)#
  		          unrestrictedsList<-llply(1:length(unrestricteds), #
  		                                    function(i){unrestrictedsList[[i]]<-c(TRUE, FALSE)},#
  		                                    .parallel=parallel)#
  		          unrestrictedsList<-c(unrestrictedsList, list(temp=1:nrow(restrictedsMatrix)))#
                names(unrestrictedsList)<-c(unrestricteds, "temp")#
                   ##Expand grid on the unconditioned variables.#
                unrestrictedsMatrix <- expand.grid(unrestrictedsList)#
                  ##Here, I'm llplying over all of the rows of the conditioned variable combination matrix#
              ##This is because temp in the unrestricted matrix takes on a new value for each model #
              ##in the conditioned matrix.So this matches temp==1 in unconditioned to row 1 #
              ##of the conditioned matrix #
              ##lply returns a list and laply doesn't work in this context, so I use do.call with rbind#
              ##to get a matrix here.#
              modelMatrix<-do.call("rbind",llply(1:nrow(restrictedsMatrix), bindTogether))#
               ##Finally, we remove temp. This makes it so modelMatrix is exactly the same but without#
              ##the temp variable.#
              modelMatrix$temp<-NULL#
              ##This ensures that the variables go back into the order they originally were in for the input#
              ##matrix of fitbma. This is essential because they can easily get out of order in the#
              ##conditioning process.#
              modelMatrix<-modelMatrix[colnames(x)]#
  		        }else{#
  		        	modelMatrix <- restrictedsMatrix#
  		        	##This ensures that the variables go back into the order they originally were in for the input#
              ##matrix of fitbma. This is essential because they can easily get out of order in the#
              ##conditioning process.#
              modelMatrix<-modelMatrix[colnames(x)]#
  		        }#
              return(modelMatrix)#
            }
modelSelect(varNames,parallel,allNothing,eitherOr,always)
allNothing
eitherOr
always
always <- "X5"
modelSelect(varNames,parallel,allNothing,eitherOr,always)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
fitBMA(x,y,g,parallel,allNothing,eitherOr,always)
always
always <- c("X5","X10")
fitBMA(x,y,g,parallel,allNothing,eitherOr,always)
summary(fitBMA(x,y,g,parallel,allNothing,eitherOr,always))
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
demo(BMAPack)
x <- matrix(rnorm(600),ncol=30)
x <- matrix(rnorm(600),ncol=20)
x
colnames(x) <- paste("X",1:20,sep="")
y <- rnorm(10)
y <- rnorm(30)
g <- 3
parallel <- TRUE
library(multicore)#
library(doMC)#
library(foreach)#
registerDoMC(cores=20)
allNothing <- list(c("X1","X2"),c("X3","X4"))
always <- c("X5","X6")
eitherOr <- list(c("X7","X8"),c("X9","X10"))
conditionals <-list(c("X11","X12"),c("X13","X14"))
conditionedOnTheseVariables <- list(c("X15","X16"),c("X17","X18"))
registerDoMC(cores=4)
fitBMA(x,y,g,parallel,allNothing,eitherOr,always,conditionals,conditionedOnTheseVariables)
a <- fitBMA(x,y,g,parallel,allNothing,eitherOr,always,conditionals,conditionedOnTheseVariables)
summary(a)
plot(a)
library(devtools)
library(roxygen2)
g <- 3#
parallel <- TRUE#
library(multicore)#
library(doMC)#
library(foreach)#
registerDoMC(cores=2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
demo(BMAPack)
library(devtools)
library(roxygen2)
g <- 3#
parallel <- TRUE#
library(multicore)#
library(doMC)#
library(foreach)#
registerDoMC(cores=2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
demo(BMAPack)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
