library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x <- matrix(rnorm(30),ncol=3)
colnames(x) <- paste("X",1:3,sep="")
y <- rnorm(10)
fitBMA(x,y)
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  s#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- apply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob))#
          }#close function definition#
)
fitBMA(x,y)
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- apply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob))#
          }#close function definition#
)
fitBMA(x,y)
set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})
set
set<-unlist(set, recursive=F)
run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }
list1<-llply(1:length(set), run.regs)
list1<-unlist(list1, recursive=F)
fits<-llply(list1, function(x){summary(x)[['r.squared']]})
fits<-unlist(fits)
coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }
coefs<-llply(1:length(set), coef.fun)
gs<-rep(g, length(set)) ##make a vector of the g value
g<-3
gs<-rep(g, length(set)) ##make a vector of the g value
ns<-rep(length(y), length(set)) ##make a vector of the n value
pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }
pks <- llply(1:length(set), pks.fun) ##running llply over "set."
pks <- unlist(pks) ##unlisting pks
pks <- as.numeric(pks) ##assigning numeric class to pks
r2s<-fits##r2 values
values<-cbind(gs, ns, pks, r2s)##make matrix of these
bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }
bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)
sum.bmk<-sum(bmk.vec)
lculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }
odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }
odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk
odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk
odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk
xiny<-function(y,x){x %in% y}
applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }
theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }
themods<-laply(1:ncol(x), theodds)
coefnamer<-function(i){
coefvec<-unlist(coefs) ##turn list of coefs into a vector.
coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name
coef1<-coefvec[coefname]
return(coef1)
}
thecoefs<-llply(1:ncol(x), coefnamer)
thecoefs<-unlist(thecoefs)
thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)
rownames(thecoefs)<-colnames(x)
ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices
exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows
exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1
names(exp.val)<-colnames(x)
coefprob<-aaply(themods, 1, sum)
names(coefprob)<-colnames(x)
index <- apply(thecoefs,1,function(x){which(x>0)})
coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))
index
index <- apply(thecoefs,1,function(x){which(x>0)})
index
thecoefs
index
index <- laply(thecoefs,1,function(x){which(x>0)})
index <- alply(thecoefs,1,function(x){which(x>0)})
index
index <- lply(thecoefs,1,function(x){which(x>0)})
index <- alply(thecoefs,1,function(x){which(x>0)})
index
coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))
coefprb.largerthanzero
coefprob.largerthanzero
index <- alply(thecoefs,1,function(x){which(x>0)})
coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- alply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob))#
          }#close function definition#
)
fitBMA(x,y)
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- alply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob,coefprobs.largerthanzero=coefprob.largerthanzero))
setMethod(f="fitBMA",#
          definition=function(x, y, g=3, parallel=TRUE,#
                              core=10){#
  library(plyr)#
  #run only if parallel is TRUE#
  if(parallel==TRUE){#
  library(foreach)#
  library(multicore)#
  library(doMC)#
  registerDoMC(cores=core) ##Will need for later for parallel stuff#
  }#
  ##Error thrown if non-unque column names.#
  if(length(unique(colnames(x)))<ncol(x)){stop("Must have unique names for each column")}#
  ##making the set#
  set <- llply(1:ncol(x),function(X){combn(ncol(x),X,simplify=F)})#
  ##making each combination a single list item#
  set<-unlist(set, recursive=F)#
#
  ##This function runs the regressions for each combination#
  run.regs<-function(i){#
    list1<-list(NULL) ##empty list#
    list1<-list(lm(scale(y)~-1+scale(x[,set[[i]]]))) ##all combinations#
    return(list1)#
  }#
#
  #Get the list of regression results#
  list1<-llply(1:length(set), run.regs)#
  ##Get rid of the outermost list, so it's one list per regression#
  list1<-unlist(list1, recursive=F)#
  ##This gets the r.squared values and puts them in a list#
  fits<-llply(list1, function(x){summary(x)[['r.squared']]})#
  ##Since lapply makes a list, we unlist to make a vector#
  fits<-unlist(fits)#
#
  ##coef.fun will later be used to extract the coefficients from the analysis. #
  ##This function also uses the setNames function in order to identify the #
  #variable for each coefficient.#
  coef.fun <- function(i){#
    coefs <- list()#
    coefs <- setNames(coef(list1[[i]]), colnames(x)[set[[i]]])#
    return(coefs)  #
  }#
  #Extracts the coefficients.#
  coefs<-llply(1:length(set), coef.fun)   #
#
  ##Create a matrix of the values needed to calculate b|mk:m0| for each model#
  gs<-rep(g, length(set)) ##make a vector of the g value#
  ns<-rep(length(y), length(set)) ##make a vector of the n value#
  ##pks.fun will later be used in llply function to create vector pks that stores#
  ##length of every element of list "set."#
  pks.fun <- function(i){ #
    pks <- list()#
    pks <- length(set[[i]])#
    return(pks)#
  }#
  pks <- llply(1:length(set), pks.fun) ##running llply over "set."#
  pks <- unlist(pks) ##unlisting pks#
  pks <- as.numeric(pks) ##assigning numeric class to pks#
  r2s<-fits##r2 values#
  values<-cbind(gs, ns, pks, r2s)##make matrix of these#
  ##function is intended to be used to aaply over the rows of the matrix above#
  bmk<-function(x){#
    bmk<-((1+x[1])^((x[2]-x[3])/2))*((1+x[1]*(1-x[4]))^(-(x[2]-1)/2))#
    names(bmk)<-c("bmk.val")#
    return(bmk)#
  }#
  ##vector of bmk values for each model#
  bmk.vec<-aaply(.data=values,.margins=1,.fun=bmk)#
  ##Sum of bmk for each model#
  sum.bmk<-sum(bmk.vec)#
  ##Fill in odds for bmk#
  ##odds.fun will later be used to calculate odds for bmk.#
  odds.fun <- function(i){ #
    odds.bmk <- list()#
    odds.bmk <- bmk.vec[i]/sum.bmk#
    return(odds.bmk)#
  }#
  odds.bmk <- llply(1:length(bmk.vec), odds.fun) ##calculating odds, and storing as odds.bmk#
  odds.bmk <- unlist(odds.bmk) ##unlisting odds.bmk#
  odds.bmk <- as.numeric(odds.bmk) ##assigning class numeric to odds.bmk#
  ##Function which returns x in y since I couldn't find what I was looking for#
  xiny<-function(y,x){x %in% y}#
  ##Function which determines which sets in the set of models include each variable#
  applier<-function(i){#
    index2<-laply(set, xiny, x=i) ##is it included in this one? True/false#
    index2<-which(index2==TRUE) ##Which ones are true?#
    return(index2)#
  }#
#
  ##Function which returns the odds of each model including the relevant variable#
  theodds<-function(i){#
    index3<-laply(1:ncol(x), applier)#
    odds.bmk[index3[i,]]#
  }#
#
  ##Get the probability values of the mods in question and put them in a matrix#
  themods<-laply(1:ncol(x), theodds)#
  ##Get the relevant coefs#
  coefnamer<-function(i){#
    coefvec<-unlist(coefs) ##turn list of coefs into a vector.#
    coefname<-which(names(coefvec)==colnames(x)[i]) ##Which coefs have a matching name#
    coef1<-coefvec[coefname]#
    return(coef1)#
  }#
#
##Apply coefnamer function over the columns of x#
  thecoefs<-llply(1:ncol(x), coefnamer) #
  thecoefs<-unlist(thecoefs)#
  thecoefs<-matrix(thecoefs, nrow=ncol(x), byrow=TRUE)#
  rownames(thecoefs)<-colnames(x)#
#
  ptimese<-themods*thecoefs ##Utilize R's practice of element-wise multiplication of matrices#
#
  exp.val1<-aaply(ptimese, 1, sum) ##Sum across the rows#
#
  exp.val<-exp.val1*(g/(g+1)) ##Multiply by g/g+1#
  names(exp.val)<-colnames(x)#
  coefprob<-aaply(themods, 1, sum)#
  names(coefprob)<-colnames(x)#
  ##'index' shows the model numbers for which each covariate has coefficient estimates larger than zero.#
  index <- alply(thecoefs,1,function(x){which(x>0)})#
  ##For each covariate, calculate the sum of model probabilities for models in which the coefficient estimate is larger than zero. Divide that by the sum of model probabilities for all models in which the covariate is included.#
  coefprob.largerthanzero <- laply(1:nrow(thecoefs),function(i){sum(themods[i,][index[[i]]])})/as.numeric(aaply(themods,1,sum))#
  return(list(x=x, y=y, thecoefs=thecoefs, combo.coef=coefs, #
             combo.fit=fits,bmk=odds.bmk, exp.vals=exp.val, coefprobs=coefprob,coefprobs.largerthanzero=coefprob.largerthanzero))#
          }#close function definition#
)
fitBMA(x,y)
library(devtools)
library(roxygen2)
current.code <- as.package("BMAPack")
load_all(current.code)
document(current.code)
x <- matrix(rnorm(30),ncol=3)
colnames(x) <- paste("X",1:3,sep="")
y <- rnorm(10)
fitBMA(x,y)
h <- fitBMA(x,y)
summary(h)
